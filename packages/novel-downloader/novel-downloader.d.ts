// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   jsdom-extra
//   bluebird
//   node-novel-info
//   moment-timezone
//   events
//   request
//   jsdom-extra/lib/from-url
//   js-tree-list2

declare module 'novel-downloader' {
    /**
      * Created by user on 2018/6/25/025.
      */
    export * from "novel-downloader/src/all";
    import sites from "novel-downloader/src/all";
    export default sites;
}

declare module 'novel-downloader/src/all' {
    /**
      * Created by user on 2018/6/25/025.
      */
    import NovelSiteWenku8 from 'novel-downloader/src/site/wenku8';
    import NovelSiteSyosetu from 'novel-downloader/src/site/syosetu';
    import NovelSiteKakuyomu from 'novel-downloader/src/site/kakuyomu';
    export { NovelSiteWenku8, NovelSiteSyosetu, NovelSiteKakuyomu, };
    import * as self from 'novel-downloader/src/all';
    export default self;
}

declare module 'novel-downloader/src/site/wenku8' {
    /**
      * Created by user on 2018/3/25/025.
      */
    import _NovelSite from 'novel-downloader/src/site/index';
    import { IDownloadOptions, INovel } from 'novel-downloader/src/site/demo/base';
    import { IFetchChapter, IOptionsRuntime } from 'novel-downloader/src/site/demo/base';
    import NovelSiteBase from 'novel-downloader/src/site/demo/base';
    import { IJSDOM } from 'jsdom-extra';
    export class NovelSiteWenku8 extends NovelSiteBase {
        static readonly IDKEY: string;
        makeUrl(urlobj: _NovelSite.IParseUrl, bool?: boolean | number): URL;
        parseUrl(url: URL | string, options?: any): _NovelSite.IParseUrl;
        createMainUrl(url: any): URL;
        protected _parseChapter<T>(ret: IFetchChapter, optionsRuntime: T & IOptionsRuntime, cache: any): string;
        get_volume_list<T = IOptionsRuntime>(inputUrl: string | URL, optionsRuntime?: Partial<T & IDownloadOptions>): Promise<INovel>;
        protected _get_meta(inputUrl: any, optionsRuntime: any, cache: {
            dom: IJSDOM;
        }): Promise<{
            novel_title: any;
            novel_cover: any;
            novel_author: any;
            novel_desc: string;
            novel_date: any;
            novel_status: any;
            novel_publisher: any;
            novel?: {
                title?: string;
                title_short?: string;
                author?: string;
                cover?: string;
                preface?: string;
                tags?: string[];
                date?: string;
                status?: string;
                r18?: string;
                series?: {
                    name?: string;
                    name_short?: string;
                    position?: number;
                };
                source?: string;
                publisher?: string;
            };
            contribute?: string[];
            options?: {
                [key: string]: any;
                textlayout?: {
                    allow_lf2?: boolean;
                };
            };
            link?: string[];
            url: URL;
            url_data: _NovelSite.IParseUrl;
        }>;
    }
    export default NovelSiteWenku8;
}

declare module 'novel-downloader/src/site/syosetu' {
    import NovelSite from 'novel-downloader/src/site/index';
    import { PromiseBluebird } from 'novel-downloader/src/site/index';
    import * as NovelSiteDemo from 'novel-downloader/src/site/demo/base';
    export type INovel = NovelSiteDemo.INovel & {
        novel_syosetu_id: string;
    };
    export type IOptionsPlus = {
        /**
          * 不使用小說家提供的 txt 下載連結
          */
        disableTxtdownload?: boolean;
    };
    export type IDownloadOptions = NovelSiteDemo.IDownloadOptions & IOptionsPlus;
    export type IOptionsRuntime = NovelSiteDemo.IOptionsRuntime & IDownloadOptions & IOptionsPlus;
    export class NovelSiteSyosetu extends NovelSiteDemo.NovelSite {
        static readonly IDKEY: string;
        constructor(options: IDownloadOptions, ...argv: any[]);
        session<T = NovelSite.IOptionsRuntime>(optionsRuntime: Partial<T & IDownloadOptions>, url: URL): this;
        download(url: string | URL, downloadOptions?: IDownloadOptions): PromiseBluebird<NovelSite.INovel>;
        protected _parseChapter<T>(ret: any, optionsRuntime: T & IOptionsRuntime, cache: any): string;
        protected _createChapterUrl<T = IOptionsRuntime & IDownloadOptions>({ novel, volume, chapter, }: {
            novel: NovelSite.INovel;
            volume: NovelSite.IVolume;
            chapter: NovelSite.IChapter;
        }, optionsRuntime?: T & IOptionsRuntime): URL;
        protected _saveReadme(optionsRuntime: IOptionsRuntime, options?: {}, ...opts: any[]): Promise<{
            file: string;
            md: string;
        }>;
        makeUrl(urlobj: NovelSite.IParseUrl, bool?: boolean): URL;
        parseUrl(url: string | URL): NovelSite.IParseUrl;
        get_volume_list<T = NovelSite.IOptionsRuntime>(url: string | URL, optionsRuntime?: Partial<T & IDownloadOptions>): Promise<INovel>;
    }
    export default NovelSiteSyosetu;
}

declare module 'novel-downloader/src/site/kakuyomu' {
    /**
        * Created by user on 2018/3/17/017.
        */
    import NovelSiteDemo, { IDownloadOptions, INovel, IOptionsRuntime } from 'novel-downloader/src/site/demo/tree';
    import NovelSite from 'novel-downloader/src/site/index';
    export class NovelSiteKakuyomu extends NovelSiteDemo {
            static readonly IDKEY: string;
            /**
                * https://kakuyomu.jp/works/4852201425154898215/episodes/4852201425154936315
                */
            makeUrl(urlobj: NovelSite.IParseUrl, bool?: boolean): URL;
            parseUrl(url: string | URL): NovelSite.IParseUrl;
            protected _parseChapter<T>(ret: any, optionsRuntime: any, cache: any): string;
            /**
                * @todo 需要改良支援三級目錄
                */
            get_volume_list<T extends IOptionsRuntime>(url: string | URL, optionsRuntime?: Partial<T & IDownloadOptions>): Promise<INovel>;
    }
    export default NovelSiteKakuyomu;
}

declare module 'novel-downloader/src/site/index' {
    /**
        * Created by user on 2018/2/10/010.
        */
    import bluebirdDecorator from 'novel-downloader/src/decorator/bluebird';
    import * as PromiseBluebird from 'bluebird';
    import { defaultJSDOMOptions, IFromUrlOptions, IOptionsJSDOM, createOptionsJSDOM } from 'novel-downloader/src/jsdom';
    export { defaultJSDOMOptions, IFromUrlOptions, IOptionsJSDOM, createOptionsJSDOM };
    import { IMdconfMeta } from 'node-novel-info';
    export { IMdconfMeta };
    import { LazyCookieJar } from 'jsdom-extra';
    import * as moment from 'moment-timezone';
    import * as EventEmitter from 'events';
    export { moment };
    export { bluebirdDecorator, PromiseBluebird };
    export const SYMBOL_CACHE: unique symbol;
    export class NovelSite implements NovelSite.INovelSite {
            static readonly IDKEY: string;
            PATH_NOVEL_MAIN: string;
            optionsInit?: NovelSite.IOptions;
            constructor(options: NovelSite.IOptions, ...argv: any[]);
            static create(options: NovelSite.IOptions, ...argv: any[]): NovelSite;
            static check(url: string | URL | NovelSite.IParseUrl, options?: any): boolean;
            session<T = NovelSite.IOptionsRuntime>(optionsRuntime: T & NovelSite.IOptionsRuntime, url?: URL): this;
            download(url: string | URL, options?: NovelSite.IDownloadOptions): PromiseBluebird<NovelSite.INovel>;
            get_volume_list<T = NovelSite.IOptionsRuntime>(url: string | URL, optionsRuntime?: Partial<T & NovelSite.IDownloadOptions>): Promise<NovelSite.INovel>;
            makeUrl(urlobj: NovelSite.IParseUrl, options?: any): URL;
            parseUrl(url: URL | string, options?: any): NovelSite.IParseUrl;
            getStatic<T = typeof NovelSite>(): T;
            readonly IDKEY: string;
            getOutputDir<T>(options?: T & NovelSite.IOptions, novelName?: string): [string, T & NovelSite.IOptions];
            protected _fixOptionsRuntime<T = NovelSite.IOptionsRuntime>(optionsRuntime: T & NovelSite.IOptionsRuntime): T & NovelSite.IOptionsRuntime;
            trimFilenameChapter(name: any): string;
            trimFilenameVolume(name: any): string;
            trimFilenameNovel(name: any): string;
            trimFilename(name: any): string;
            protected _saveReadme(optionsRuntime?: IOptionsRuntime, options?: {}, ...opts: any[]): Promise<{
                    file: string;
                    md: string;
            }>;
            createMainUrl(url: string): URL;
            createMainUrl(url: URL): URL;
            protected _createChapterUrl<T = IOptionsRuntime>({ novel, volume, chapter, }: {
                    novel: NovelSite.INovel;
                    volume: NovelSite.IVolume;
                    chapter: NovelSite.IChapter;
            }, optionsRuntime?: T & IOptionsRuntime): URL;
            protected _fetchChapter<T>(url: URL, optionsRuntime: T & IOptionsRuntime): void;
            protected _parseChapter<T>(dom: any, optionsRuntime: T & IOptionsRuntime, cache: {
                    file: string;
                    novel: NovelSite.INovel;
                    volume: NovelSite.IVolume;
                    chapter: NovelSite.IChapter;
            }): void;
            protected _checkExists(optionsRuntime: IOptionsRuntime, file: string): boolean;
            protected emit(event: EventEmitter, eventName: string, ...argv: any[]): (boolean | EventEmitter)[];
    }
    export import IOptionsRuntime = NovelSite.IOptionsRuntime;
    export import IVolume = NovelSite.IVolume;
    export import IChapter = NovelSite.IChapter;
    export namespace NovelSite {
            type IOptionsPlus = {
                    disableOutputDirPrefix?: boolean;
                    noDirPrefix?: boolean;
                    noDirPadend?: boolean;
                    noFirePrefix?: boolean;
                    noFilePadend?: boolean;
                    retryDelay?: number;
                    startIndex?: number;
                    filePrefixMode?: number;
                    allowEmptyVolumeTitle?: boolean;
                    event?: EventEmitter;
                    /**
                        * 用來登入站點的 cookies session
                        */
                    sessionData?: {
                            [key: string]: any;
                    };
                    /**
                        * 只抓取小說的 META 資料
                        */
                    fetchMetaDataOnly?: boolean;
            };
            type IOptions = {
                    outputDir?: string;
                    cwd?: string;
            } & IOptionsPlus;
            type IDownloadOptions = {
                    /**
                        * 只產生目錄結構 不下載內容
                        */
                    disableDownload?: boolean;
                    disableCheckExists?: boolean;
                    optionsJSDOM?: IFromUrlOptions & IOptionsJSDOM & {
                            cookieJar?: Partial<LazyCookieJar>;
                    };
            } & IOptionsPlus;
            type IOptionsRuntime = IOptions & IDownloadOptions & IOptionsPlus;
            interface IParseUrl {
                    url?: URL | string;
                    novel_pid?: any;
                    novel_id?: any;
                    chapter_id?: any;
                    novel_r18?: any;
                    [key: string]: any;
            }
            interface IChapter {
                    chapter_index?: number | string;
                    chapter_title: string;
                    chapter_id?: any;
                    chapter_url?: any;
                    chapter_url_data?: any;
                    chapter_date?: moment.Moment;
                    [key: string]: any;
            }
            interface IVolume {
                    volume_index?: any;
                    volume_title: string;
                    chapter_list?: IChapter[];
                    [key: string]: any;
            }
            interface INovel {
                    url: URL | string;
                    url_data: IParseUrl;
                    novel_title: string;
                    novel_author?: string;
                    novel_desc?: string;
                    novel_date?: moment.Moment;
                    novel_publisher?: string;
                    novel_series_title?: string;
                    volume_list: IVolume[];
                    checkdate?: moment.Moment;
                    imgs?: string[];
                    [key: string]: any;
            }
            interface INovelSiteStatic<T> extends Type<T & NovelSite.INovelSite> {
                    IDKEY: string;
            }
            interface INovelSite {
                    download(url: string | URL, options?: IDownloadOptions): PromiseBluebird<NovelSite.INovel>;
                    makeUrl(urlobj: NovelSite.IParseUrl, options?: any): URL;
                    parseUrl(url: URL | string): NovelSite.IParseUrl;
            }
    }
    export interface Type<T> {
            new (options: NovelSite.IOptions, ...args: any[]): T;
    }
    export function staticImplements<T>(): (constructor: T) => void;
    export default NovelSite;
}

declare module 'novel-downloader/src/site/demo/base' {
    import { IJSDOM } from 'jsdom-extra';
    import _NovelSite from 'novel-downloader/src/site/index';
    import { PromiseBluebird } from 'novel-downloader/src/site/index';
    export type IOptionsPlus = {};
    export type IDownloadOptions = _NovelSite.IDownloadOptions & _NovelSite.IOptions & IOptionsPlus;
    export type IOptionsRuntime = _NovelSite.IOptionsRuntime & IOptionsPlus;
    export import INovel = _NovelSite.INovel;
    import { ResponseRequest } from 'request';
    export type IFetchChapter = {
        body?: any;
        dom?: IJSDOM;
        res?: ResponseRequest;
        json?: any;
    };
    export type ISessionData = {
        [key: string]: any;
    };
    export class NovelSiteDemo extends _NovelSite {
        static readonly IDKEY: string;
        constructor(options: IDownloadOptions, ...argv: any[]);
        /**
          * @todo 讓此方法有意義
          *
          * 用來說明目前站點的所需 session cookies
          *
          * @param {T} data
          * @returns {T}
          */
        checkSessionData<T = ISessionData>(data: T, optionsRuntime?: IOptionsRuntime): T;
        session<T = IOptionsRuntime>(optionsRuntime: Partial<T & IDownloadOptions>, url: URL): this;
        download(inputUrl: string | URL, downloadOptions?: IDownloadOptions): PromiseBluebird<_NovelSite.INovel>;
        protected _processNovel<T = any>(novel: INovel, optionsRuntime: IOptionsRuntime, _cache_: {
            url: URL;
            path_novel: string;
        }, ...argv: any[]): Promise<T>;
        processNovel<T>(novel: INovel, optionsRuntime: IOptionsRuntime, _cache_: {
            url: URL;
            path_novel: string;
        }, ...argv: any[]): PromiseBluebird<{
            novel: _NovelSite.INovel;
            optionsRuntime: _NovelSite.IOptionsRuntime;
            _cache_: {
                url: URL;
                path_novel: string;
            };
            ret: T;
        }>;
        protected _parseChapter<T>(ret: IFetchChapter, optionsRuntime: T & IOptionsRuntime, cache: {
            file: string;
            novel: _NovelSite.INovel;
            volume: _NovelSite.IVolume;
            chapter: _NovelSite.IChapter;
        }): string | Promise<string>;
        protected _fetchChapter<T>(url: URL, optionsRuntime: T & IOptionsRuntime): PromiseBluebird<IFetchChapter>;
        protected _saveReadme(optionsRuntime: IOptionsRuntime, options?: {}, ...opts: any[]): Promise<{
            file: string;
            md: string;
        }>;
        protected _get_meta(inputUrl: any, optionsRuntime: any, cache?: {
            dom?: IJSDOM;
        }): void;
    }
    export const NovelSite: typeof NovelSiteDemo;
    export default NovelSiteDemo;
}

declare module 'novel-downloader/src/site/demo/tree' {
    /**
      * Created by user on 2018/4/4/004.
      */
    export * from 'novel-downloader/src/site/demo/base';
    import _NovelSiteBase, { IDownloadOptions, IOptionsRuntime as _IOptionsRuntime, INovel as _INovel } from 'novel-downloader/src/site/demo/base';
    import { IRowChapter, IRowVolume, NovelTree } from 'novel-downloader/src/tree/index';
    export { NovelTree };
    export type IOptionsRuntime = _IOptionsRuntime & {
        novelTree?: NovelTree;
    };
    export type INovel = _INovel & {
        novelTree?: NovelTree;
    };
    export class NovelSiteDemo extends _NovelSiteBase {
        getOutputDir<T extends IOptionsRuntime & IDownloadOptions>(options: T, novelName?: string): [string, T];
        protected _processNovelListName(novel: INovel, optionsRuntime: IOptionsRuntime, ...argv: any[]): Promise<{
            id?: string | number;
            parent?: string | number;
            uuid?: string;
            content: import("../../tree").IRowRoot<{}> | IRowVolume<{}> | IRowChapter<{}>;
        }[]>;
        _processNovel<T>(novel: INovel, optionsRuntime: IOptionsRuntime, _cache_: {
            url: URL;
            path_novel: string;
        }, ...argv: any[]): Promise<T>;
        protected _saveReadme(optionsRuntime: IOptionsRuntime, options?: {}, ...opts: any[]): Promise<{
            file: string;
            md: string;
        }>;
    }
    export const NovelSite: typeof NovelSiteDemo;
    export default NovelSiteDemo;
}

declare module 'novel-downloader/src/decorator/bluebird' {
    /**
      * Created by user on 2018/2/10/010.
      */
    import * as PromiseBluebird from 'bluebird';
    export { PromiseBluebird };
    export const bluebirdDecorator: MethodDecorator;
    export function bluebirdDecorator2<T>(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor;
    export default bluebirdDecorator2;
}

declare module 'novel-downloader/src/jsdom' {
    /**
      * Created by user on 2018/3/18/018.
      */
    import { IFromUrlOptions, VirtualConsole, IOptionsJSDOM, IFromFileOptions } from 'jsdom-extra';
    export { IFromUrlOptions, VirtualConsole, IOptionsJSDOM, IFromFileOptions };
    import { LazyCookie, LazyCookieJar } from 'jsdom-extra';
    export { LazyCookie, LazyCookieJar };
    import { IOptions, IOptionsCreateQuery } from 'jsdom-extra';
    import { IRequestOptions } from 'jsdom-extra/lib/from-url';
    export type INovelOptionsJSDOM = IFromUrlOptions & IOptionsJSDOM;
    export const defaultJSDOMOptions: IFromUrlOptions;
    export function createOptionsJSDOM<T = INovelOptionsJSDOM>(options?: Partial<T & INovelOptionsJSDOM>, ...opts: INovelOptionsJSDOM[]): Partial<T & INovelOptionsJSDOM>;
    export function getOptions(options: any): {
        options: Partial<IOptionsJSDOM>;
        fromURLOptions: Partial<IOptionsCreateQuery & IOptions & {
            minifyHTML?: boolean;
        } & IFromUrlOptions>;
        requestOptions: Partial<IRequestOptions>;
    };
    import * as self from 'novel-downloader/src/jsdom';
    export default self;
}

declare module 'novel-downloader/src/tree/index' {
    /**
      * Created by user on 2018/4/2/002.
      */
    import { Tree, Node, ITreeToList } from 'js-tree-list2';
    import { IChapter, IVolume } from 'novel-downloader/src/site/index';
    export type ITreeID = string | number;
    export { ITreeToList };
    export type TreeNode<T = IRowRoot | IRowVolume | IRowChapter> = Node<T>;
    export interface ITree {
        level?: number;
        type?: string;
        total_idx?: number;
        idx?: number;
        name?: string;
    }
    export type IRowVolume<T = {}> = T & IVolume & ITree & {
        type?: 'volume';
        volume_index?: string | number;
        volume_title: string;
        dirname?: string;
        volume_level?: string | number;
    };
    export type IRowChapter<T = {}> = T & IChapter & ITree & {
        type?: 'chapter';
        chapter_index?: string | number;
        chapter_title: string;
        chapter_id?: string | number;
        chapter_url?: URL;
        chapter_url_data?: any;
        chapter_date?: any;
        path?: string;
    };
    export type IRowRoot<T = {}> = ITree & {
        type?: 'root';
    } & T;
    export type IRowNovel = IRowVolume | IRowChapter;
    export class NovelTree {
        tree: Tree<IRowRoot | IRowVolume | IRowChapter>;
        cache: {
            lastVolume?: Node<IRowVolume>;
            lastChapter?: Node<IRowChapter>;
            depth?: number;
        };
        constructor(initData?: Partial<IRowRoot>);
        root(): Node<IRowRoot<{}> | IRowVolume<{}> | IRowChapter<{}>>;
        addVolume<U extends IRowVolume>(value: U, root?: Node): Node<U>;
        addChapter<U extends IRowChapter>(value: U, root?: Node): Node<U>;
        static isVolume(node: Node): node is Node<IRowVolume>;
        static isVolume(node: IRowVolume): node is IRowVolume;
        static isChapter(node: Node): node is Node<IRowChapter>;
        static isChapter(node: IRowChapter): node is IRowChapter;
        protected _fixRow<U extends Node<IRowVolume | IRowChapter>>(node: U): U;
        protected _getRoot<U extends Node<IRowRoot | IRowVolume | IRowChapter>>(root: U): U;
        toJSON(): any;
        static treeToList(novelTree: NovelTree, linkNode?: boolean): {
            id?: string | number;
            parent?: string | number;
            uuid?: string;
            content: IRowRoot<{}> | IRowVolume<{}> | IRowChapter<{}>;
        }[];
    }
    export default NovelTree;
}

